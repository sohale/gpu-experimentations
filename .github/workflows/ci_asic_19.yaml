# Always use name, otherwise it will be confusing
# Always repeat the type!
name: Workflow for ASIC using OpenLANE and/or FPGA

on: # To web-hook to which events: "push", "PR" (creation or modificaiotn), "manual trigger"
  push: # e-enable to avoid many clicks each time. Comment out later.
  pull_request:
  workflow_dispatch:

permissions:
  contents: read # Always needed.
  packages: read # This grants our GITHUB_TOKEN read access to GitHub Packages (GHCR). We are not creating (docker build ing)

# Workflow for experiment 19: ASIC using OpenLANE and/or FPGA


jobs:
  # deprecated since replaced by dockerimage approach
  verilog-yosis-environment-prepare--deprecated:
    # verilog-yosis-full:
    # todo: use dockerbuilder approach instead of this job, based on: .github/docker/ub_pyenv.dockerfile
    #     and defer it to: .github/workflows/build-ub-pyenv-image.yaml

    # deprecarted
    if: false


    runs-on: ubuntu-latest # docker image
    # each is a fresh, isolated VM or container
    # can target a different OS, VM type, or custom label
    # it’s a GitHub-hosted runner label. Not a "docker run -it ubuntu"
    # List: https://github.com/actions/runner-images
    #   preloaded with tools
    #  not docker image!
    #
    # Across jobs: (if differnt, or even the same "runner-image")
    #    not shared live
    #    No layer reuse across jobs
    #    No container layering

    # `job`s are fully isolated: state, image-contents.
    # Different filesystem. All layers are separate.
    # environment : different, not shared, instantiated.
    # No disk layer sharing
    # Different processes
    # No memory sharing


    # Hence, a new concept: "runner-image", which is Not "docker-image". But parallels that.

    # So, How to share data between jobs:
    #    artifacts: upload-artifact / download-artifact
    #    "cache keys"

    # So, how to use docker-image as a "runner-image"? (instead of.)
    #    Add a `container.image: yosys/yosys:latest`
    #      private (docker) registries possible
    #      Not to confise with "runner-image registries", e.g. https://github.com/actions/runner-images
    #  A host VM, and the docker image is inside it:
    #     inside the specified Docker container, which is "inside" (nested docker in docker).
    #     you can specify its docker-registry too (since it is fetched inside that "VM": meta-image). AKA "native runner".
    #     Hence, runner-image is a meta-image (VM-docker relationship, that is nested).


    # Conceptology:
    #   * runner-image
    #   * cache-key
    #   * artifact


    steps:

      - name: Prepare environment pyenv + ubuntu (to be moved to a docker image)
        run: |
          set -eux
          # see also : https://gist.github.com/jprjr/7667947

          export PYTHON_VERSION=3.12.3
          # Yosys says it is tested on 3.6.

          # GITHUB_ENV lines must be v=v , without anything else:
          echo "PYTHON_VERSION=$PYTHON_VERSION" >> "$GITHUB_ENV"

          sudo apt-get update

          # todo: Many of may be not necessary for 'pyenv':
          sudo apt-get install -y --no-install-recommends \
            make \
            build-essential \
            libssl-dev zlib1g-dev libbz2-dev libreadline-dev \
            libsqlite3-dev \
            wget \
            ca-certificates \
            curl \
            libncurses5-dev \
            libncursesw5-dev \
            xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev mecab-ipadic-utf8 \
            \
            coreutils \
            \
            git \
            make

            # removed:
            #        llvm \

          # coreutils was for 'cat':
          cat --version || echo "no cat found"
          which cat || echo "no cat found"


          echo "Ready to install pyenv"

          # pyenv is not in apt
          # sudo apt-get install -y  pyenv

          export PYENV_ROOT="$HOME/dot.pyenv"
          # mkdir -p "$PYENV_ROOT"
          curl https://pyenv.run | bash

          export PYENV_ROOT="$HOME/dot.pyenv"
          mkdir -p "$PYENV_ROOT"

          # DRY:
          export PATH=$PYENV_ROOT/shims:$PYENV_ROOT/bin:$PATH

          # forbidden:
          # pyenv init  # dont miss this? No: You actually should not do that. You wrap it in `eval`. There is no installation `init`. But how will it know `pyenv`? Perhaps: PATH.

          # eval "$(ssh-agent -s)" # never do this!
          eval "$(pyenv init -)" # this is the correct one. (Default usage?)

          echo "pyenv ssh-agent eval succeeded."
          echo "Pre-update pyenv version:"
          pyenv version
          python --version

          pyenv update \
              || echo "err code: $?" \
              || :  # A non-critical step that may fail. FIXME.
          # Can be slow:
          pyenv install $PYTHON_VERSION
          pyenv global $PYTHON_VERSION
          # pyenv shell $PYTHON_VERSION
          pyenv rehash

          echo "Done installing pyenv"

          # Set up environment for the next steps

          echo "export PYENV_ROOT=\"$PYENV_ROOT\""
          echo "PYENV_ROOT=$PYENV_ROOT" >> "$GITHUB_ENV"
          echo 'debug0.0'
          # Wrong: Must fully expand: # echo 'PATH=$PYENV_ROOT/shims:$PYENV_ROOT/bin:$PATH' >> "$GITHUB_ENV"
          echo "PATH=$PYENV_ROOT/shims:$PYENV_ROOT/bin:$PATH" >> "$GITHUB_ENV"
          echo 'debug0.1'
          cat "$GITHUB_ENV"
          echo 'debug0.2'
          # The "$GITHUB_ENV" is automatically sourced in the next steps
          # eval "$(ssh-agent -s)" # You cannot GITHUB_ENV this. Repeat at each step.
          # pyenv version
          # python --version
          echo 'debug0.4'

      - name: Test use of pyenv
        run: |
          set -eux
          echo 'debug1'
          echo "PATH:=$PATH"
          echo 'debug1.0'
          echo "GITHUB_ENV=$GITHUB_ENV"
          echo 'debug1.1'
          cat "$GITHUB_ENV" # Needed to see the actual contents carried by GITHUB_ENV.
          echo 'debug1.2'
          env
          echo 'debug1.3'
          echo
          echo 'debug1.4'
          echo $PYENV_ROOT # failed here
          eval "$(ssh-agent -s)"
          echo 'debug2'
          env || :
          echo 'debug3'
          pyenv version || : # Why fails?

          python --version

          # more information about the environment
          pyenv global
          pyenv versions
          pyenv version-file
          pyenv which python3
          pyenv exec /usr/bin/echo "$(python3 --version)" || :


          # All future steps need to start with:
          # set -eux ; eval "$(ssh-agent -s)"

# This section is commented to merge into the same "job":
# Separated after
  # jobs:
  verilog-yosis-full:
    # amaranth-verilog-yosis-asic
    # riscv-formal:  # job name

    #needs: verilog-yosis-environment-prepare--deprecated:
    # replaced by the docker approach

    runs-on: ubuntu-latest
    # Runs on a docker image, not directly on the host VM (parent/hyper-image GH-Action's)
    # Steps are run inside the container, rather than directly on the host VM: (is docker-mediated)
    #         Another approach could have been: use docker inside a ".container:." approach, but I guess it does not work because docker is not good for docker-in-docker nesting.

    container:
      image: ghcr.io/yourname/ub-pyenv-image:latest

    # initiate experiment 19: ASIC using OpenLANE

    steps:
      - name: check out myself
        uses: actions/checkout@v4
        with:
          # default is: ${{ github.repository }}, i.e. same repo.
          # repository: git@github.com:sohale/gpu-experimentations.git
          submodules: 'recursive'
          # fetch-depth: '' # default is 1!
          # clean: '' # clean / hard-reset before fetching
          # ref: '' # sha or branch to checkout
        # $GITHUB_WORKSPACE
        # path: where to clone it into

      - name: cp my neurasic1.v
        run: |
          echo "github.repository: ${{ github.repository }}"
          pwd
          ls -alth
          cd gpu-experimentations || :
          pwd
          ls -alth
          echo 'TARGET_DIR=experiments/19_asic_lane/yosis-build' >> "$GITHUB_ENV"
          TARGET_DIR="experiments/19_asic_lane/yosis-build"
          mkdir -p "$TARGET_DIR"
          pwd
          cd "$TARGET_DIR"
          pwd

      - name: Checkout my verilog file
        uses: actions/checkout@v4 # registered (official) GH Action name
        with:
          sparse-checkout: | # pull a single file
            experiments/19_asic_lane/neurasic1.v
          sparse-checkout-cone-mode: false

      - name: skipped
      #- name: Checkout riscv-formal
        # never run:
        # if: never()
        if: false # never run
        uses: actions/checkout@v4
        with:
          #repository: YosysHQ/riscv-formal
          #path: experiments/19_asic_lane/build/riscv-formal
          # repository: YosysHQ/????
          # https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2024-06-04
          # https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2025-07-21
          # https://github.com/YosysHQ/oss-cad-suite-build/releases/download/2025-07-21/oss-cad-suite-linux-x64-20250721.tgz
          # ./builder.py build --target=yosys : to create docker image
          # `click` ? https://pypi.org/project/click/
          path: experiments/19_asic_lane/yosis-build

      - uses: YosysHQ/setup-oss-cad-suite@v3
        # https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2025-07-01
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download and extract OSS CAD Suite
        run: |
          set -eux ; eval "$(ssh-agent -s)"

          cd "$TARGET_DIR"
          wget https://github.com/YosysHQ/oss-cad-suite-build/releases/download/2025-07-21/oss-cad-suite-linux-x64-20250721.tgz
          tar -xvzf oss-cad-suite-linux-x64-20250721.tgz
          ls -alth

      - name: cp my neurasic1.v
        run: |
          set -eux ; eval "$(ssh-agent -s)"

          # TARGET_DIR="experiments/19_asic_lane/yosis-build"
          # mkdir -p "$TARGET_DIR"
          echo "TARGET_DIR: $TARGET_DIR"
          cp experiments/19_asic_lane/neurasic1.v --target-directory="$TARGET_DIR"
          cd "$TARGET_DIR"

      - name: make checks
        run: |
          set -eux ; eval "$(ssh-agent -s)"

          # export TARGET_DIR="experiments/19_asic_lane/yosis-build"
          cd "$TARGET_DIR"
          echo "empty1"
          pwd
          echo "This will fail. Under construction (1)"
          make checks -j$(nproc)
          # see https://github.com/YosysHQ/picorv32/blob/main/Makefile

      - name: Test python installtion using pyenv to reach here
        run: |
          set -eux ; eval "$(ssh-agent -s)"
          pyenv version || : # Why fails?

          python --version

      - name: make check
        run: |
          set -eux ; eval "$(ssh-agent -s)"

          # cd riscv-formal/cores/picorv32
          # make check
          export TARGET_DIR="experiments/19_asic_lane/yosis-build"
          cd "$TARGET_DIR"
          echo "empty2"
          pwd
          echo "Under construction (2)"

  quick-build:
    # needs: verilog-yosis-environment-prepare--deprecated:
    runs-on: ubuntu-latest # same
    steps:

      - name: checkout,git-pull self-repo
      # checkout the repo before running the steps
      uses: actions/checkout@v4
      # a step cannot have both the uses and run keys:
      # run: | ...


      - name: TBC

        run: |
          set -eux ; eval "$(ssh-agent -s)"
          echo 'TARGET_DIR=experiments/19_asic_lane/yosis-build' >> "$GITHUB_ENV"
          . "$GITHUB_ENV"

          echo "Check environment variables"
          env
          pwd  # /home/runner/work/gpu-experimentations/gpu-experimentations
          ls -alth # Is it already pulled?! Answer: No.
           # So, why is it "gpu-experimentations/gpu-experimentations"?
          ls -alth ..
          cd "$TARGET_DIR"
          pwd
          ls
          pyenv version
          python --version


  # Based on locally "published" docker image
  # Lesson: You cannot build it here (on the fly). At least using this method.
  quick-based-on-pulling-docker-image:
  # Wrong name:
  # quick-build-based-on-docker-image:
    # independent: no "needs:"
    runs-on: ubuntu-latest

    container:
      image: ghcr.io/${{ github.repository_owner }}/ub-pyenv-image:latest
      options: --user root  # optional: add extra Docker run args

    steps:

      - name: Check Python version
        run: python --version

      - name: Show current user
        run: whoami




  testin-pulling-docker-image-based-on-login:
    runs-on: ubuntu-latest


    # no "container:" or "container.image:"
    # Explicitly pulls into the Host VM (but equivalently).


    steps:

      # Login necessary before (push &) pull
      - name: Login to GHCR, nececsary for pull-ing the image
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Python version
        run: |
          # explicitly pulling
          docker pull ghcr.io/${{ github.repository_owner }}/ub-pyenv-image:latest
          docker run \
              --rm -it \
              ghcr.io/${{ github.repository_owner }}/ub-pyenv-image:latest \
              bash -c "echo Inside image with pyenv setup ; pyenv versions ; echo ; python --version" \
          echo "back to outside the docker-[live-]image, in the GHA above-container"
          echo "finne."

      - name: Show current user
        run: whoami


# Inspirations from:
# https://github.com/YosysHQ/picorv32/blob/main/.github/workflows/ci.yml
# 87c89acc18994c8cf9a2311e871818e87d304568

# /myvol/tpu_poc/qtpu/dev-env
